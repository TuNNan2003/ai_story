# Grandma 前端

一个基于 React 和 Vite 构建的现代化智能对话界面，提供类似 GPT 的用户体验，支持实时流式响应、打字机效果展示和完整的 Markdown 渲染能力，特别针对长篇故事创作场景提供了灵感模式。

## 📋 目录

- [特性](#特性)
- [技术架构](#技术架构)
- [核心功能实现](#核心功能实现)
- [UI 设计与交互](#ui-设计与交互)
- [快速开始](#快速开始)
- [项目结构](#项目结构)
- [开发指南](#开发指南)

## ✨ 特性

Grandma 前端系统提供了完整的智能对话交互体验，通过 React 框架构建了现代化的用户界面，实现了类似 GPT 的聊天体验。系统核心功能包括实时流式响应接收，当后端返回流式数据时，前端能够实时接收并展示，配合打字机效果组件，AI 的响应会逐字显示，为用户提供流畅的交互体验。系统支持完整的 Markdown 渲染能力，包括标题、列表、代码块、表格、引用块、链接和图片等所有 Markdown 元素，并且所有样式都已适配深色主题，确保在深色背景下有良好的可读性。

系统设计支持两种工作模式，以适应不同的使用场景。普通对话模式提供了简洁的对话界面，用户可以在侧边栏查看和管理对话历史，选择不同的对话继续交流，系统会自动加载对话的历史消息。灵感模式则专门为长篇故事创作进行了优化，不仅提供了创作历史管理功能，还实现了右侧面板展示 AI 创作内容，支持文档列表管理和文档编辑功能。在灵感模式下，用户可以创建多个创作项目，每个项目包含多个文档片段，系统会在右侧面板实时展示 AI 生成的内容，并且支持查看历史文档、编辑文档内容和重命名文档等功能。

在消息布局方面，系统采用了清晰的设计方案，用户消息显示在右侧，使用绿色色块（#10a37f）突出显示，AI 消息显示在左侧，使用深灰色色块（#2f2f2f）显示，这种设计使得对话的流向一目了然。消息的最大宽度设置为 70%，既保证了良好的阅读体验，又不会占用过多屏幕空间。圆角设计进一步优化了视觉效果，用户消息的右上角和右下角采用圆角，AI 消息的左上角和左下角采用圆角，这种不对称的设计增强了消息的区分度。

在交互体验方面，系统实现了智能的输入控制机制。当 AI 正在响应时，用户可以继续输入下一次请求的内容，但发送按钮和 Enter 键会被禁用，防止用户在 AI 响应过程中发送新消息，避免打断 AI 的响应流程。当响应完成后，系统会自动恢复发送功能，用户可以正常发送消息。系统还实现了消息历史的分页加载功能，当用户查看历史对话时，可以通过滚动到顶部自动加载更早的消息，系统会保持用户的滚动位置，确保加载新消息后用户仍然能看到之前查看的内容。

在数据请求优化方面，前端采用了轻量级的请求策略，每次请求仅发送当前用户输入的消息内容，不包含历史消息，这样既减少了请求体的大小，又提高了请求速度。后端负责管理对话历史和上下文，前端只需要关注当前交互，这种设计使得前后端职责清晰，系统更加高效。

## 🏗️ 技术架构

系统采用 React 18 作为核心框架，使用 Vite 作为构建工具，提供了快速的开发体验和高效的构建性能。整体架构采用组件化设计，将功能拆分为多个独立的组件，每个组件专注于自己的职责，通过 props 传递数据和回调函数实现组件间的通信。

主应用组件 `App.jsx` 负责整体的状态管理和业务逻辑协调，它维护了消息列表、对话历史、创作列表、模型列表等核心状态，处理用户的各种操作，包括发送消息、选择对话、创建新对话、切换模式等。组件通过 `useState` 管理本地状态，通过 `useRef` 管理需要在异步操作中访问的引用，通过 `useEffect` 处理副作用，包括数据获取、状态同步等。

聊天容器组件 `ChatContainer` 是核心的交互组件，它负责消息列表的展示、输入区域的管理和流式响应的处理。在灵感模式下，它还负责右侧面板的展示和编辑功能。消息列表组件 `MessageList` 负责渲染消息列表，支持分页加载和自动滚动。单条消息组件 `Message` 负责渲染单条消息，根据消息角色（用户或 AI）应用不同的样式。Markdown 渲染组件 `MarkdownRenderer` 负责将 AI 返回的 Markdown 内容渲染为 HTML，结合打字机效果组件 `Typewriter` 实现逐字显示的效果。

输入区域组件 `EnhancedInputArea` 提供了增强的输入功能，包括模型选择、发送按钮、修改原文选项等。侧边栏组件根据当前模式显示不同的内容，普通模式下显示 `ConversationHistory`，灵感模式下显示 `WorkHistory`。对话历史组件和创作历史组件都支持折叠、调整宽度、重命名、删除等功能，宽度设置会保存到 localStorage，确保用户下次打开时保持之前的设置。

系统使用 React Hooks 进行状态管理，通过 `useState` 管理组件状态，通过 `useEffect` 处理生命周期和副作用，通过 `useRef` 管理需要在异步操作中访问的值，通过 `useCallback` 优化回调函数的性能。这种设计使得代码更加简洁，逻辑更加清晰，同时充分利用了 React 的性能优化机制。

## 🔧 核心功能实现

### 流式响应处理

流式响应处理是前端系统的核心功能之一，它通过 Server-Sent Events (SSE) 技术接收后端返回的流式数据。当用户发送消息后，前端会创建一个 EventSource 连接或者使用 Fetch API 的流式读取功能，实时接收后端返回的数据块。每个数据块到达后，系统会立即更新消息列表，将新内容追加到当前 AI 消息的内容中，同时触发打字机效果组件重新渲染，实现逐字显示的效果。

在这个过程中，系统需要处理多个技术挑战。首先是状态同步问题，流式响应是异步的，需要确保状态更新不会丢失数据，也不会产生竞态条件。系统通过使用函数式更新 `setMessages(prev => ...)` 来确保状态更新的原子性，每次更新都基于前一个状态，避免了并发更新导致的数据丢失。其次是滚动位置管理，当新内容到达时，系统需要判断是否自动滚动到底部，如果用户正在查看历史消息，则不应该自动滚动，只有在用户处于底部附近时才自动滚动。系统通过监听滚动事件和计算滚动位置来实现这个功能，当用户滚动到非底部位置时，系统会记录用户正在主动滚动，此时不会自动滚动到底部。

流式响应结束后，系统需要处理元数据，包括文档 ID 等信息。系统通过解析响应末尾的元数据标记来获取这些信息，然后更新消息对象，添加文档 ID 等元数据，这些元数据在后续操作中会用到，比如在灵感模式下查看和编辑文档。

### 打字机效果实现

打字机效果是系统的重要交互特性，它通过 `Typewriter` 组件实现。当 AI 消息的内容更新时，打字机组件会检测内容的变化，然后逐字符地显示新内容，创造出打字的效果。实现过程中，组件需要处理内容的部分更新，当流式响应过程中内容不断追加时，组件需要识别出新增的部分，只对新增部分应用打字机效果，而不是重新显示整个内容。

组件通过比较当前显示的内容和实际内容来识别新增部分，然后使用 `setInterval` 或者 `requestAnimationFrame` 逐字符地追加新内容。为了优化性能，组件会批量处理字符，而不是逐字符更新 DOM，这样可以减少重绘次数，提高性能。组件还支持暂停和恢复功能，当用户滚动到非底部位置时，可以暂停打字机效果，当用户滚动回底部时，恢复打字机效果。

打字机效果与 Markdown 渲染的结合是一个技术难点，因为 Markdown 内容需要先解析为 HTML，然后才能应用打字机效果。系统通过将 Markdown 解析和打字机效果分离，先解析 Markdown 内容，然后在渲染时应用打字机效果，通过控制显示的内容长度来实现逐字显示的效果。

### 双模式支持

系统支持两种工作模式，普通对话模式和灵感模式，两种模式在界面布局、功能特性上都有显著差异。普通对话模式下，界面采用传统的聊天布局，左侧显示对话历史，中间是聊天区域，用户消息和 AI 消息交替显示。灵感模式下，界面采用三栏布局，左侧是创作历史，中间是聊天区域，右侧是文档展示和编辑区域。

模式切换通过顶部的切换开关实现，切换时会清空当前消息和状态，加载对应模式的数据。普通模式下加载对话列表，灵感模式下加载创作列表。两种模式共享大部分核心功能，包括消息发送、流式响应接收、Markdown 渲染等，但在数据管理和界面展示上有显著差异。

灵感模式的右侧面板是独特的特性，它实时展示 AI 生成的内容，支持查看历史文档，支持编辑文档内容。当 AI 响应完成或用户选择查看历史文档时，右侧面板会显示对应的内容，用户可以点击编辑按钮进入编辑模式，修改内容后点击保存按钮将修改保存到后端。编辑功能通过 `textarea` 实现，保存功能通过调用后端 API 实现，保存成功后会更新本地状态和消息列表。

### Markdown 渲染

Markdown 渲染功能通过 `react-markdown` 库实现，该库提供了完整的 Markdown 解析和渲染能力。系统配置了 `remark-gfm` 插件，支持 GitHub 风格的 Markdown，包括表格、删除线、任务列表等扩展语法。所有 Markdown 元素都应用了自定义样式，适配深色主题，确保在深色背景下有良好的可读性。

渲染过程中，系统需要处理代码块的高亮显示，虽然当前实现没有集成代码高亮库，但代码块的样式已经优化，使用等宽字体和适当的背景色，确保代码的可读性。表格渲染支持完整的表格功能，包括表头、单元格对齐等。链接和图片的渲染也经过了优化，链接使用适当的颜色和悬停效果，图片支持自适应大小。

Markdown 渲染与打字机效果的结合需要特殊处理，因为 Markdown 内容需要先解析为 HTML，然后才能应用打字机效果。系统通过控制渲染的内容长度来实现，每次只渲染部分内容，然后逐步增加，创造出打字的效果。这个过程需要确保 Markdown 语法的完整性，不能在半途中截断，否则会导致渲染错误。

### 状态管理与数据同步

系统的状态管理采用 React 的本地状态管理，通过 `useState` 管理组件状态，通过 `useRef` 管理需要在异步操作中访问的值。主应用组件维护了全局状态，包括消息列表、对话列表、创作列表、当前对话 ID、当前创作 ID 等。子组件通过 props 接收数据和回调函数，通过回调函数更新父组件状态。

数据同步是一个重要的技术挑战，因为流式响应是异步的，用户操作也可能在异步进行，需要确保状态的一致性。系统通过使用 `useRef` 存储需要在异步操作中访问的值，比如当前对话 ID、当前创作 ID 等，这些值在异步操作中可能会变化，使用 ref 可以确保访问到最新的值。系统还通过 `useEffect` 同步 ref 和 state，确保两者保持一致。

本地存储的使用也是状态管理的一部分，用户 ID、侧边栏宽度等设置会保存到 localStorage，确保用户下次打开时保持之前的设置。用户 ID 的生成和保存确保了多次打开网页时 ID 一致，这对于后端的数据隔离和 RAG 功能非常重要。

## 🎨 UI 设计与交互

系统采用了简洁而优雅的 UI 设计，使用深色主题，整个界面使用统一的深灰色背景（#343541），营造出专业的氛围。颜色方案非常简洁，只使用了三种主要颜色：背景色是深灰色，用户消息使用绿色（#10a37f）突出显示，AI 消息使用更深的灰色（#2f2f2f）显示。这种设计使得界面简洁明了，不会分散用户的注意力。

消息布局采用了清晰的对齐方式，用户消息右对齐，AI 消息左对齐，这种设计符合用户的阅读习惯，使得对话的流向一目了然。消息的最大宽度设置为 70%，既保证了良好的阅读体验，又不会占用过多屏幕空间。圆角设计进一步优化了视觉效果，用户消息的右上角和右下角采用圆角，AI 消息的左上角和左下角采用圆角，这种不对称的设计增强了消息的区分度，使得用户能够快速识别消息的来源。

侧边栏设计支持折叠和调整宽度，用户可以根据需要调整侧边栏的宽度，宽度设置会保存到 localStorage。侧边栏可以完全折叠，为聊天区域提供更多空间。在普通模式下，侧边栏显示对话历史和故事列表，用户可以快速切换对话，查看和管理故事。在灵感模式下，侧边栏显示创作历史，用户可以管理多个创作项目。

响应式设计确保了系统在不同屏幕尺寸下都能正常工作。虽然当前实现主要针对桌面端优化，但基本的响应式特性已经实现，界面会根据屏幕尺寸自动调整布局。输入区域的设计考虑了不同输入方式，支持键盘输入和鼠标点击发送，支持 Enter 键发送和 Shift+Enter 换行。

交互反馈是用户体验的重要组成部分，系统实现了多种交互反馈机制。当用户发送消息时，输入框会显示加载状态，发送按钮会被禁用。当 AI 响应时，输入框仍然可以输入，但发送功能被禁用，防止用户打断 AI 的响应。消息发送和接收都有适当的视觉反馈，用户消息立即显示，AI 消息通过打字机效果逐步显示。

## 🚀 快速开始

系统要求 Node.js 16 或更高版本，以及 npm 或 yarn 包管理器。安装过程非常简单，首先进入前端目录，然后运行 `npm install` 安装所有依赖。依赖安装完成后，运行 `npm run dev` 启动开发服务器，前端应用将在 `http://localhost:5173` 启动（Vite 的默认端口）。

开发服务器支持热模块替换（HMR），当代码修改时，浏览器会自动刷新，显示最新的更改，这大大提高了开发效率。开发过程中，需要确保后端服务也在运行，因为前端需要调用后端 API 才能正常工作。

构建生产版本时，运行 `npm run build` 命令，构建工具会优化代码，压缩资源，生成生产就绪的静态文件。构建产物会输出到 `dist` 目录，可以直接部署到任何静态文件服务器。构建过程会进行代码分割，将代码拆分为多个 chunk，实现按需加载，提高首屏加载速度。

## 📁 项目结构

系统采用清晰的目录结构，按照功能进行组织。`src` 目录包含了所有源代码，`components` 子目录包含了所有 React 组件。主应用组件 `App.jsx` 位于 `src` 目录的根目录，负责整体的状态管理和业务逻辑协调。入口文件 `main.jsx` 负责初始化 React 应用，挂载到 DOM。

组件目录按照功能进行了细分，聊天相关的组件包括 `ChatContainer`、`MessageList`、`Message` 等，这些组件共同实现了聊天界面的核心功能。Markdown 渲染相关的组件包括 `MarkdownRenderer` 和 `Typewriter`，实现了 Markdown 内容的渲染和打字机效果。输入相关的组件包括 `InputArea` 和 `EnhancedInputArea`，提供了输入功能和模型选择功能。历史管理相关的组件包括 `ConversationHistory` 和 `WorkHistory`，实现了对话历史和创作历史的管理。文档管理相关的组件包括 `WorkDocumentList` 和 `InspirationDocumentView`，实现了灵感模式下的文档管理功能。对话框组件包括 `StoryEditDialog`、`StoryViewDialog` 和 `DeleteConfirmDialog`，提供了各种交互对话框。

样式文件与组件文件放在同一目录，使用相同的文件名加上 `.css` 后缀，这样使得组件和样式的关系更加清晰。全局样式文件 `index.css` 位于 `src` 目录，定义了全局的样式规则和 CSS 变量。

## 💻 开发指南

系统使用 React 18 和现代 JavaScript 特性，代码采用函数式组件和 Hooks 进行开发。组件开发遵循单一职责原则，每个组件专注于自己的功能，通过 props 接收数据和回调函数，通过回调函数与父组件通信。状态管理采用本地状态管理，通过 `useState` 管理组件状态，通过 `useEffect` 处理副作用。

代码组织遵循 React 的最佳实践，组件文件使用 PascalCase 命名，样式文件使用小写字母和连字符命名。组件内部按照逻辑进行组织，首先是导入语句，然后是组件定义，最后是导出语句。Hooks 的使用遵循 React 的规则，只在组件的顶层调用 Hooks，不在循环、条件或嵌套函数中调用 Hooks。

性能优化是开发过程中需要考虑的重要方面。系统通过 `useCallback` 优化回调函数的性能，避免不必要的重新渲染。通过 `useMemo` 优化计算密集型操作，避免重复计算。通过 `React.memo` 优化组件渲染，避免不必要的组件重新渲染。流式响应处理中，系统批量更新状态，减少状态更新次数，提高性能。

错误处理是系统健壮性的重要保障。系统实现了完善的错误处理机制，当 API 请求失败时，会显示错误消息，不会导致整个应用崩溃。流式响应处理中，系统会处理网络错误、解析错误等各种异常情况，确保用户体验不受影响。

测试是保证代码质量的重要手段，虽然当前实现没有包含测试代码，但建议为关键组件编写单元测试，为关键功能编写集成测试。测试应该覆盖正常流程和异常流程，确保系统在各种情况下都能正常工作。

## 📝 许可证

本项目采用 MIT 许可证。

## 🤝 贡献

欢迎提交 Issue 和 Pull Request！

---

**注意**：本项目仍在积极开发中，API 和功能可能会有变化。建议在生产环境使用前进行充分测试。
